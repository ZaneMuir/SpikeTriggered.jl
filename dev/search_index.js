var documenterSearchIndex = {"docs":
[{"location":"api/#APIs","page":"APIs","title":"APIs","text":"","category":"section"},{"location":"api/#Stats","page":"APIs","title":"Stats","text":"","category":"section"},{"location":"api/","page":"APIs","title":"APIs","text":"Modules = [\n    SpikeTriggered.Stats,\n    SpikeTriggered.Stats.SpatialRF,\n    ]\nOrder   = [:function, :type]","category":"page"},{"location":"api/#SpikeTriggered.Stats.benjamini_hochberg_qvalue-Tuple{AbstractArray}","page":"APIs","title":"SpikeTriggered.Stats.benjamini_hochberg_qvalue","text":"benjamini_hochberg_qvalue(pvalue; C=1) -> (q::Array, k::Array)\n\nFalse discovery rate test for any list of pvalues. This function will return the q value and the corresponding k index.\n\nP_k leq frackN alpha\n\nq_k = fracNk P_k leq alpha\n\nk is generated from invperm(sortperm(...)).\n\n\n\n\n\n","category":"method"},{"location":"api/#SpikeTriggered.Stats.burst_detect-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T<:Real","page":"APIs","title":"SpikeTriggered.Stats.burst_detect","text":"burst_detect(spk::Vector; t_silence=0.07, t_isi=0.03, nofs=nothing, keep_index=false) -> Vector{Vector{T}}\n\nBurst firing identification based on the rules:\n\na burst would followed/preceded by a silence t_silence time;\n\nif t_silence is a 2 element tuple, the t_silence[1] will set the preceded time and t_silence[2] will be the followed time.\n\neach spike spaced at most t_isi time, otherwise terminated\n(optional) at least nofs[1] spikes within the first nofs[2] time\n\nIf keep_index is true, will return indices of spikes within the input; otherwise, the spike times will be returned.\n\nReferences:\n\nVaingankar et al 2012\n\n\n\n\n\n","category":"method"},{"location":"api/#SpikeTriggered.Stats.burst_detect_lgn-Tuple{Any}","page":"APIs","title":"SpikeTriggered.Stats.burst_detect_lgn","text":"detect_burst_lgn(spk; kwargs...)\n\nBursts were defined as two or more spikes, each spaced ≤4 ms apart following ≥100 ms of silence, bursts rarely lasted more than 10 ms for LGN.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpikeTriggered.Stats.burst_detect_trn-Tuple{Any}","page":"APIs","title":"SpikeTriggered.Stats.burst_detect_trn","text":"detect_burst_trn(spk; kwargs...)\n\n≥5 spikes within 70 ms, spaced ≤30 ms apart following ≥70 ms of silence; bursts were terminated when the interspike interval exceeded 30 ms, Figure 1B. Thus defined, typical bursts had 5–17 spikes. Typical bursts lasted between 70 and 100 ms.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpikeTriggered.Stats.burst_interpolate-Tuple{AbstractVector}","page":"APIs","title":"SpikeTriggered.Stats.burst_interpolate","text":"interp_burst(burst_iti::AbstractVector; n=13, interp_t=:steffen) -> Vector{Float64}\ninterp_burst(bursts::Vector{Vector{Real}}; n=13, interp_t=:steffen) -> Matrix{Float64} [n x nBursts]\n\nMake interpolation of burst inter-spike-interval to generate burst patterns.\n\nn set the interpolation bin length. interp_t set the type of interpolation, currently only supports [:linear, :polynomial, :cspline, :steffen]. The results will always be in Cdouble precision.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpikeTriggered.Stats.covariogram-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}}} where T<:Real","page":"APIs","title":"SpikeTriggered.Stats.covariogram","text":"The covariogram is defined as:\n\nV equiv langle (S_1^r - P_1) odot (S_2^r - P_2) rangle = langle S_1^r odot S_2^r rangle - P_1 odot P_2\n\n\n\n\n\n","category":"method"},{"location":"api/#SpikeTriggered.Stats.dispersion_index-Tuple{Any}","page":"APIs","title":"SpikeTriggered.Stats.dispersion_index","text":"dispersion_index(psth; corrected=true, kwargs...) -> Real\n\nAlso known as the Fano factor.\n\nD = fracsigma^2mu\n\noptional arguments:\n\ndims: calculate the index over dimension dims.\n\nCheck out more on wikipedia.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpikeTriggered.Stats.gaussian_kernel-Tuple{T} where T<:AbstractFloat","page":"APIs","title":"SpikeTriggered.Stats.gaussian_kernel","text":"gaussian_kernel(x::T; σ::T=0.005)\n\nInline Gaussian function.\n\ng(x) = fracexp(-fracx^22 σ^2)sqrt2pi σ\n\n\n\n\n\n","category":"method"},{"location":"api/#SpikeTriggered.Stats.get_footprint_map-Tuple{Function, AbstractArray}","page":"APIs","title":"SpikeTriggered.Stats.get_footprint_map","text":"get_footprint_map([func_pval,] raw::AbstractArray; alpha=0.01, fdr_c=1, collapse=false, gridsize=nothing)\n\nCreate a footprint map based on the q-values from func_pval(raw) using Benjamini–Hochberg procedure; alpha as the threshold, fdr_c as the constant.\n\nP_k leq frackN cdot C alpha\n\nFor arbiturary join distribution of p-values, one could set fdr_c as ln(N)+1/N+γ (Euler constant). (using benjamini_hochberg_constant(N))\n\nIf collapse is true and gridsize is specified, a 2d time-collapsed footprint map will be returned.\n\ncolor codes as:\n\n1: ON response\n0: NO response\n-1: OFF response\n\n\n\n\n\n","category":"method"},{"location":"api/#SpikeTriggered.Stats.get_footprint_mask-Tuple{Function, AbstractArray}","page":"APIs","title":"SpikeTriggered.Stats.get_footprint_mask","text":"get_footprint_mask([func_pval::Function,] raw::AbstractArray; alpha=0.01, fdr_c=1)\n\nCreate a binary footprint mask based with Benjamini–Hochberg procedure using arbiturary q-values converted from raw statistic values by func_pval.\n\nIn most cases, one should use get_footprint_map which can also generate 3d mask with addtional polarity information.\n\nIf func_pval is not set, zscore_pvalue will be used, which assumes inputs are zscore from standard normal distribution.\n\nalpha if the threshold for false discovery rate, default as 0.01.\n\nfdr_c is the constant value for correcting Benjamini–Hochberg procedure with joint distributions among pvalues.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpikeTriggered.Stats.get_footprint_mask_from_qvalue-Tuple{Any, Any}","page":"APIs","title":"SpikeTriggered.Stats.get_footprint_mask_from_qvalue","text":"get_footprint_mask_from_qvalue(qval, k; alpha=0.01)\n\ncreate a binary footprint mask based on the q-values and the corresponding permutation vector. Using Benjamini–Hochberg procedure.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpikeTriggered.Stats.get_histogram_center-Tuple{AbstractVector}","page":"APIs","title":"SpikeTriggered.Stats.get_histogram_center","text":"get_histogram_center(edges)\n\nget the center of edge vector. make sure edges are sorted.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpikeTriggered.Stats.histogram_fhist-Tuple{AbstractVector, Any}","page":"APIs","title":"SpikeTriggered.Stats.histogram_fhist","text":"histogram_fhist(u_arr, edges; kwargs...) -> Vector\n\nCount histogram using FHist.Hist1D, which has similar performance as GSL.\n\nkwargs will be relayed to FHist.Hist1D; for example, one could set element type of the histogram to Float32 by passing counttype=Float32.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpikeTriggered.Stats.histogram_gsl-Union{Tuple{T}, Tuple{AbstractVector{T}, Any}} where T<:Real","page":"APIs","title":"SpikeTriggered.Stats.histogram_gsl","text":"histogram_gsl(u_arr, edges) where {T <: Real}\n\nCount histogram by providing the edges. If provides n+1 edges, it would return n length histogram. Edges would work as: left bound <= value < right bound.\n\nArguments\n\nu_arr: a vector of values\nedges: a vector of edges\n\nNote: StatsBase.Histogram is slower than GSL but with less memory footprint.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpikeTriggered.Stats.hstack_strf-Tuple{AbstractArray}","page":"APIs","title":"SpikeTriggered.Stats.hstack_strf","text":"hstack_strf(val; gridsize) -> Array{T, 2} Sx(SxT)\n\nconvert strf 3d matrix into horizontal matrix.\n\nWhen plotting with heatmap, REMEMBER to use the transversed matrix and reversed y axis.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpikeTriggered.Stats.image2dataset-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T","page":"APIs","title":"SpikeTriggered.Stats.image2dataset","text":"image2dataset(image::AbstractMatrix) -> ([X Y], [Z])\n\nconvert 2d image into (x, y) coordinates and vector of elements (z). Primarilly used for 2d gaussian fit.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpikeTriggered.Stats.make_strf-Tuple{AbstractArray}","page":"APIs","title":"SpikeTriggered.Stats.make_strf","text":"make_strf(val; gridsize) -> Array{T, 3} SxSxT\n\nconvert strf vector into 3d spatiotemporal matrix.\n\nWhen plotting with heatmap, REMEMBER to use the transversed matrix and reversed y axis.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpikeTriggered.Stats.schreiber_score_matrix-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T<:Real","page":"APIs","title":"SpikeTriggered.Stats.schreiber_score_matrix","text":"Schreiber reliability score:\n\nR_textcorr = frac2N(N-1) sum_i = 1^N sum_j = i+1 ^N fracvecs_i cdot vecs_jvecs_i vecs_j\n\nInput in shape of [nPSTH x nTrial]\n\nreference: dx.doi.org/10.1016/S0925-2312(02)00838-X\n\n\n\n\n\n","category":"method"},{"location":"api/#SpikeTriggered.Stats.spike_histogram-Tuple{AbstractVector, AbstractMatrix}","page":"APIs","title":"SpikeTriggered.Stats.spike_histogram","text":"spike_histogram(spike_train, edges::AbstractMatrix; kwargs...) -> Matrix{T}\n\nPeri-stimulus time histogram with multiple trials. edges should be shape of [n+1 x nRepeats] to create a histogram of shape [n x nRepeats].\n\nIf dims is specified, trial dimension will be overwrite.\n\nAdditional kwargs will be passed to spike_histogram.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpikeTriggered.Stats.spike_histogram-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector}} where T<:Real","page":"APIs","title":"SpikeTriggered.Stats.spike_histogram","text":"spike_histogram(spike_train::AbstractVector{T}, edges::AbstractVector; dtype::Type, kwargs...) -> Vector{T}\n\nPeri-stimulus time histogram. edges should be length of n+1 to create a histogram of length n.\n\nIf spike_train is empty, it will return zeros(T, n)\n\nIf counttype is not specified, the returned vector will have same type T\n\n\n\n\n\n","category":"method"},{"location":"api/#SpikeTriggered.Stats.spike_histogram-Union{Tuple{T}, Tuple{Array{Vector{T}, 1}, Vararg{Any}}} where T<:Real","page":"APIs","title":"SpikeTriggered.Stats.spike_histogram","text":"spike_histogram(raster::SpikeRaster{T}, args...; norm=true, kwargs...) -> VecOrMat{T}\n\nPSTH from averaging rasters.\n\nIf norm is true, PSTH will be normalized by the length of trials.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpikeTriggered.Stats.spike_histogram_smoothed-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractArray}, Tuple{AbstractVector{T}, AbstractArray, Function}} where T<:Real","page":"APIs","title":"SpikeTriggered.Stats.spike_histogram_smoothed","text":"spike_histogram_smoothed(spike_train::SpikeTrain{T}, projection::AbstractArray, kernel::Function=gaussian_kernel; norm=true, kwargs...) -> Vector{T}\n\nGenerating smoothed curve from spike trains. Equivalent to convolution.\n\ntextPSTH(t) = (h * s)(t) = sum_i delta(t - t_i) h (t - t_i) t in textproj\n\nIf norm is true, the results will be normalized by the maximum value.\n\nAll kwargs will be passed to kernel function.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpikeTriggered.Stats.spike_histogram_smoothed-Union{Tuple{T}, Tuple{Array{Vector{T}, 1}, Vararg{Any}}} where T<:Real","page":"APIs","title":"SpikeTriggered.Stats.spike_histogram_smoothed","text":"spike_histogram_smoothed(raster, args...; kwargs...) where {T <: Real} -> Vector{T}\n\nGenerating smoothed PSTH from rasters.\n\nIf norm is true, PSTH will be normalized to the maximum number; otherwise, it will be divided by the number of trials in the raster.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpikeTriggered.Stats.spike_raster-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector}} where T<:Real","page":"APIs","title":"SpikeTriggered.Stats.spike_raster","text":"spike_raster(spike_train::AbstractVector{T}, markers::AbstractVector; head=0.5, duration=1.0, tail=0.5, offset=true) -> Vector{Vector{T}}\n\nCreate rasters from spike_train and onset times of stimulus (markers), with interval of (marker-head, marker+duration+tail].\n\nIf offset is true, spike times of each trial be relative to the onset time.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpikeTriggered.Stats.spike_train_spectrum_power-Union{Tuple{T}, Tuple{AbstractVector{T}, Any}} where T<:AbstractFloat","page":"APIs","title":"SpikeTriggered.Stats.spike_train_spectrum_power","text":"spike_train_spectrum_power(spks::AbstractSpikeTrain{T}, freq; t_len=1) where {T <: AbstractFloat}\n\nThe spike-train power spectrum is computed from the Fourier transform of the spike train, as in (Dummer, et al., 2014).\n\nS(f) = fraclangle tildex tildex^ast rangleT\n\nThe neural spike train is represented by a sum of delta functions at the spike times:\n\nx(t) = sum_i delta(t - t_i)\n\nThe Fourier transform for the time window is defined by\n\ntildex(f) = int_0^T e^- 2 pi j f t x(t) dt\n\nReference:\n\nDummer, B., Wieland, S. & Lindner, B. Self-consistent determination of the spike-train power spectrum in a neural network with sparse connectivity. Front. Comput. Neurosci. 8, (2014). DOI: 10.3389/fncom.2014.00104\n\n\n\n\n\n","category":"method"},{"location":"api/#SpikeTriggered.Stats.spike_triggered_average-Tuple{AbstractMatrix, AbstractVector}","page":"APIs","title":"SpikeTriggered.Stats.spike_triggered_average","text":"spike_triggered_average(stimulus, psth; n=10)\nspike_triggered_average(stimulus, spike_train, marker; n=10)\nspike_triggered_average(stimulus, raster, marker; n=10)\n\nGet the STA, which can be reshaped into 2d/3d matrix with make_strf and hstack_strf.\n\nIf psth is 2d matrix (nTimepoints x nRepeats), the average of PSTH across trials will be used.\n\nA = frac1N sum_n=1^Nvecs(t_n)\n\n\n\n\n\n","category":"method"},{"location":"api/#SpikeTriggered.Stats.spike_triggered_average_suite-Tuple{Any, Vararg{Any}}","page":"APIs","title":"SpikeTriggered.Stats.spike_triggered_average_suite","text":"spike_triggered_average_suite(args...; kwargs...) -> (; diff, on, off)\n\nCreate STAs of difference map, on map and off map; returns a named tuple.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpikeTriggered.Stats.spike_triggered_average_zscore-Tuple","page":"APIs","title":"SpikeTriggered.Stats.spike_triggered_average_zscore","text":"spike_triggered_average_zscore(args...; kwargs...)\n\nEstimate z-scores of STA.\n\nSame args... as spike_triggered_average.\n\nIf n is specified, only n frames are included for zscore (same as sta, default as 10`).\n\nbootstrap set the bootstrapping iterations, default as 1000.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpikeTriggered.Stats.spike_triggered_covariance-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractArray{T}}} where T","page":"APIs","title":"SpikeTriggered.Stats.spike_triggered_covariance","text":"spike_triggered_covariance(X::AbstractMatrix{T}, y::AbstractArray{T}; n::Integer=10, verbose=true) where {T, U} -> Matrix{T}\n\n\n\n\n\n","category":"method"},{"location":"api/#SpikeTriggered.Stats.spike_xcorr-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector}} where T<:Real","page":"APIs","title":"SpikeTriggered.Stats.spike_xcorr","text":"spike_xcorr(target, reference, roi) where {T <: Real}\n\nThe crosscorrelogram shows a count of the spikes of the target cell at specific time delays with respect the spikes of the reference cell.\n\nIf there are multiple trials, use the spike_xcorr_shifted to correct any bias with a shift predictor.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpikeTriggered.Stats.spike_xcorr_shifted-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector}} where T<:Real","page":"APIs","title":"SpikeTriggered.Stats.spike_xcorr_shifted","text":"spike_xcorr_shifted(target, reference, roi; shift_t, shift_t_end) where {T <: Real}\n\nThe crosscorrelogram shows a count of the spikes of the target cell at specific time delays with respect the spikes of the reference cell. Corrected with a shift predictor.\n\nKeyword Arguments:\n\nshift_t: Δt of each shift, usually shift the spike by trials\nshifttend: the end limit of spike_time, usually the end time of the last trial. [default: maximum(reference)]\n\n\n\n\n\n","category":"method"},{"location":"api/#SpikeTriggered.Stats.split_tonic_burst-Tuple{Any}","page":"APIs","title":"SpikeTriggered.Stats.split_tonic_burst","text":"split_tonic_burst(spk; detector, kwargs...) -> (; burst::Vector{Vector}, tonic::Vector)\n\nSplit spike train into burst and tonic groups using detector function.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpikeTriggered.Stats.split_tonic_cardinal-Tuple{Any}","page":"APIs","title":"SpikeTriggered.Stats.split_tonic_cardinal","text":"split_tonic_cardinal(spk; detector, kwargs...) -> (; burst::Vector, tonic::Vector)\n\nSplit spike train into burst and tonic groups using detector function. But only the cardinal spike of burst is returned.\n\n\n\n\n\n","category":"method"},{"location":"api/#SpikeTriggered.Stats.zscore_pvalue-Tuple{AbstractArray}","page":"APIs","title":"SpikeTriggered.Stats.zscore_pvalue","text":"zscore_pvalue(zscore::AbstractArray; two_tailed=true)\n\nget pvalue from standard normal distribution\n\n\n\n\n\n","category":"method"},{"location":"api/#SpikeTriggered.Stats.SpatialRF.schiller_overlap_index-Tuple{SpikeTriggered.Stats.SpatialRF.GaussianEllipse, SpikeTriggered.Stats.SpatialRF.GaussianEllipse}","page":"APIs","title":"SpikeTriggered.Stats.SpatialRF.schiller_overlap_index","text":"schiller_overlap_index(e1::GaussianEllipse, e2::GaussianEllipse)\n\noverlap of two spatial receptive fields based on Schiller's overlap index.\n\nFor two receptive fields with the Gaussian parameters (alpha, sigma_a, sigma_b, theta, x_0, y_0), the 2D overlap index is defined as:\n\nOmega = fracsigma_12 + sigma_21 - dsigma_12 + sigma_21 + d\n\nWhere d is the Euclidian distance between the centers, and:\n\nsigma_ij = fracsigma_aisigma_bisqrt\nsigma_ai^2 sin^2(theta_i - phi_ij) +\nsigma_bi^2 cos^2(theta_i - phi_ij)\n\n\nphi_ij = arctanleft(fracy_0j - y_0ix_0j - x_0iright)\n\nReferences\n\nSchiller et al., 1979\nWang et al., 2007\n\n\n\n\n\n","category":"method"},{"location":"api/#Waveforms","page":"APIs","title":"Waveforms","text":"","category":"section"},{"location":"api/","page":"APIs","title":"APIs","text":"Modules = [\n    SpikeTriggered.Waveforms\n    ]\nOrder   = [:function, :type]","category":"page"},{"location":"api/#SpikeTriggered.Waveforms.detect_cross_pnt-Union{Tuple{Vector{T}}, Tuple{T}} where T","page":"APIs","title":"SpikeTriggered.Waveforms.detect_cross_pnt","text":"detect_cross_pnt(arr; thresh, gap=1, dir=:up, ref=nothing)\n\ndetect data rise or data down points.\n\nArguments\n\narr: a vector of traces.\nthresh: threshold\n\n\n\n\n\n","category":"method"},{"location":"api/#SpikeTriggered.Waveforms.gaussian_filter_gsl-Tuple{Vector{Float64}}","page":"APIs","title":"SpikeTriggered.Waveforms.gaussian_filter_gsl","text":"gaussian_filter_gsl(arr::Vector{Float64}; K::Integer, α::Real=1)\n\nThe GSL gaussian kernel is defined by:\n\nG(k) = expleft(- frack^22 sigma^2right)\n\nfor -(K-1)2 leq k leq (K-1)2, and K is the size of the kernel. The parameter alpha specifies the number of standard deviations sigma desired in the kernel.\n\nsigma = fracK-12 alpha\n\n\n\n\n\n","category":"method"},{"location":"api/#Stimulus","page":"APIs","title":"Stimulus","text":"","category":"section"},{"location":"api/","page":"APIs","title":"APIs","text":"Modules = [\n    SpikeTriggered.Stimulus\n    ]\nOrder   = [:function, :type]","category":"page"},{"location":"api/#SpikeTriggered.Stimulus.apply_video_nonlinearity","page":"APIs","title":"SpikeTriggered.Stimulus.apply_video_nonlinearity","text":"apply_video_nonlinearity(video, bias=0) -> video\n\nFor sparse noise stimuli, to retrieve nonlinear map (ON map and OFF map) by ignore bright/dark spots.\n\nArguments\n\nvideo: the original video matrix\nbias: could be either values or symbols\nON: :on or -1\nOFF: :off or 1\nDIFF: :diff or 0\n\n\n\n\n\n","category":"function"},{"location":"api/#SpikeTriggered.Stimulus.load_snra-Tuple{String}","page":"APIs","title":"SpikeTriggered.Stimulus.load_snra","text":"load_snra(snf_path::String) -> Vector{Int16}\n\nread snf sparse noise pseudorandom files\n\nSynopsis\n\nstruct SNF {\n    int16_t n_order;\n    int32_t base_poly; // not sure what it represents\n    int16_t* snra; // the length would be 2^n_order\n};\n\n\n\n\n\n","category":"method"},{"location":"api/#SpikeTriggered.Stimulus.parse_snra-Union{Tuple{T}, Tuple{Array{T}, Integer}} where T<:Integer","page":"APIs","title":"SpikeTriggered.Stimulus.parse_snra","text":"parse_snra(snra::Array{T}, grid_size::Integer) -> NamedTuple(:ids, :row, :col, :sign)\n\nparse the snra array to sparse noise image info.\n\n\n\n\n\n","category":"method"},{"location":"raster_psth/#Raster-and-PSTH","page":"Raster and PSTH","title":"Raster and PSTH","text":"","category":"section"},{"location":"raster_psth/","page":"Raster and PSTH","title":"Raster and PSTH","text":"Raster plot and peristimulus time histogram(PSTH) are very useful for neural activities to periodic stimuli or repeated trials. Patterns of firing can be easily seen and further analyized when spikes are aligned with the onsets of the stimulus.","category":"page"},{"location":"raster_psth/","page":"Raster and PSTH","title":"Raster and PSTH","text":"In most cases, spike trains are stored as Vector{T} where T <: Real. Mathematically, it can be represented as series of Dirac delta function:","category":"page"},{"location":"raster_psth/","page":"Raster and PSTH","title":"Raster and PSTH","text":"    operatornames(t) = sum_i delta(t - t_i)","category":"page"},{"location":"raster_psth/","page":"Raster and PSTH","title":"Raster and PSTH","text":"where t_i is the spike times in the spike train vector.","category":"page"},{"location":"raster_psth/#Getting-Rasters","page":"Raster and PSTH","title":"Getting Rasters","text":"","category":"section"},{"location":"raster_psth/","page":"Raster and PSTH","title":"Raster and PSTH","text":"Rasters will be created as Vector{Vector{T}} using spike_raster, where each subvector will be spike times relative to the stimulus onset. Besides the spike train, you should at least have the onset time of the stimulus (marker::AbstractVector), and specify the length of time before the onset (head) and duration of the stimulus and time after the stimulus (tail).","category":"page"},{"location":"raster_psth/","page":"Raster and PSTH","title":"Raster and PSTH","text":"using SpikeTriggered\nspike_train = rand(1000) * 50\nmarker_onset = 0:10:40\nraster = spike_raster(spike_train, marker_onset; head=0.5, duration=1.0, tail=0.5)\n...","category":"page"},{"location":"raster_psth/#Getting-PSTHs","page":"Raster and PSTH","title":"Getting PSTHs","text":"","category":"section"},{"location":"raster_psth/","page":"Raster and PSTH","title":"Raster and PSTH","text":"Histogram style PSTHs can be generated with spike_histogram, and FHist is used under the hook. In order to have finer control and a nonlinear timescale (e.g., when you want to group each trial into 0-100ms and 100ms-500ms as triggering phase and steady phase), edges of the histogram is taken. So, don't forget to append the last right edge.","category":"page"},{"location":"raster_psth/","page":"Raster and PSTH","title":"Raster and PSTH","text":"edges = 0:0.01:50.0\npsth = spike_histogram(spike_or_raster, edges)","category":"page"},{"location":"raster_psth/","page":"Raster and PSTH","title":"Raster and PSTH","text":"note: Note\nIf you need PSTHs for each single trial, you can organize the edges into 2d Matrix as [edges x nTrials], which results into 2d raster as [n x nTrials]; an easy way to generate such matrix:projection = 0:0.001:2\ntrial_onset = [0,5,10,15,20]\nedge_2d = projection .+ trial_onset' # 2d edge matrix\npsth_2d = spike_histogram(spike_train, edge_2d)","category":"page"},{"location":"raster_psth/","page":"Raster and PSTH","title":"Raster and PSTH","text":"note: Note\nthe PSTH from raster has an additional kwargs norm=true which will normalized the PSTH by the number of trials.","category":"page"},{"location":"raster_psth/#Getting-smoothed-PSTHs","page":"Raster and PSTH","title":"Getting smoothed PSTHs","text":"","category":"section"},{"location":"raster_psth/","page":"Raster and PSTH","title":"Raster and PSTH","text":"Sometimes, it's arbitary to find a good bin size, or you just want to smooth the histogram; you can use a kernel function to generate a smooth PSTH using spike_histogram_smoothed. Essentially, it is a convolution over time steps provided by projection::AbstractVector.","category":"page"},{"location":"raster_psth/","page":"Raster and PSTH","title":"Raster and PSTH","text":"operatornamePSTH(t) = (operatornameh * operatornames)(t) = sum_i delta(t - t_i) h(t - t_i) t in textprojection","category":"page"},{"location":"raster_psth/","page":"Raster and PSTH","title":"Raster and PSTH","text":"where h is the kernel function, t_i is the spike time. By default, it uses a Gaussian kernel function (Stats.gaussian_kernel).","category":"page"},{"location":"raster_psth/","page":"Raster and PSTH","title":"Raster and PSTH","text":"# Gaussian kernel with default sigma = 0.005\nspike_histogram_smoothed(spike_or_raster, projection)\n\n# change the Gaussian kernel width\nspike_histogram_smoothed(spike_or_raster, projection; σ=0.010)","category":"page"},{"location":"raster_psth/","page":"Raster and PSTH","title":"Raster and PSTH","text":"note: Note\nThe kernel function shoudl be defined as (dt; kwargs...) -> ...:my_kernel(dt; thresh) = dt < thresh ? 0 : 1\npsth = spike_histogram_smoothed(spike_or_raster, projection, my_kernel; thresh=0.5)","category":"page"},{"location":"raster_psth/","page":"Raster and PSTH","title":"Raster and PSTH","text":"note: Note\nThere is also a norm=true flag, to normalize the PSTH by its maximum value, so the PSTH will be between [0, 1].","category":"page"},{"location":"raster_psth/#Functions","page":"Raster and PSTH","title":"Functions","text":"","category":"section"},{"location":"raster_psth/#exported-functions","page":"Raster and PSTH","title":"exported functions","text":"","category":"section"},{"location":"raster_psth/","page":"Raster and PSTH","title":"Raster and PSTH","text":"spike_raster\nspike_histogram\nspike_histogram_smoothed","category":"page"},{"location":"raster_psth/#SpikeTriggered.Stats.spike_raster","page":"Raster and PSTH","title":"SpikeTriggered.Stats.spike_raster","text":"spike_raster(spike_train::AbstractVector{T}, markers::AbstractVector; head=0.5, duration=1.0, tail=0.5, offset=true) -> Vector{Vector{T}}\n\nCreate rasters from spike_train and onset times of stimulus (markers), with interval of (marker-head, marker+duration+tail].\n\nIf offset is true, spike times of each trial be relative to the onset time.\n\n\n\n\n\n","category":"function"},{"location":"raster_psth/#SpikeTriggered.Stats.spike_histogram","page":"Raster and PSTH","title":"SpikeTriggered.Stats.spike_histogram","text":"spike_histogram(spike_train::AbstractVector{T}, edges::AbstractVector; dtype::Type, kwargs...) -> Vector{T}\n\nPeri-stimulus time histogram. edges should be length of n+1 to create a histogram of length n.\n\nIf spike_train is empty, it will return zeros(T, n)\n\nIf counttype is not specified, the returned vector will have same type T\n\n\n\n\n\nspike_histogram(spike_train, edges::AbstractMatrix; kwargs...) -> Matrix{T}\n\nPeri-stimulus time histogram with multiple trials. edges should be shape of [n+1 x nRepeats] to create a histogram of shape [n x nRepeats].\n\nIf dims is specified, trial dimension will be overwrite.\n\nAdditional kwargs will be passed to spike_histogram.\n\n\n\n\n\nspike_histogram(raster::SpikeRaster{T}, args...; norm=true, kwargs...) -> VecOrMat{T}\n\nPSTH from averaging rasters.\n\nIf norm is true, PSTH will be normalized by the length of trials.\n\n\n\n\n\n","category":"function"},{"location":"raster_psth/#SpikeTriggered.Stats.spike_histogram_smoothed","page":"Raster and PSTH","title":"SpikeTriggered.Stats.spike_histogram_smoothed","text":"spike_histogram_smoothed(spike_train::SpikeTrain{T}, projection::AbstractArray, kernel::Function=gaussian_kernel; norm=true, kwargs...) -> Vector{T}\n\nGenerating smoothed curve from spike trains. Equivalent to convolution.\n\ntextPSTH(t) = (h * s)(t) = sum_i delta(t - t_i) h (t - t_i) t in textproj\n\nIf norm is true, the results will be normalized by the maximum value.\n\nAll kwargs will be passed to kernel function.\n\n\n\n\n\nspike_histogram_smoothed(raster, args...; kwargs...) where {T <: Real} -> Vector{T}\n\nGenerating smoothed PSTH from rasters.\n\nIf norm is true, PSTH will be normalized to the maximum number; otherwise, it will be divided by the number of trials in the raster.\n\n\n\n\n\n","category":"function"},{"location":"raster_psth/#utility-functions","page":"Raster and PSTH","title":"utility functions","text":"","category":"section"},{"location":"raster_psth/","page":"Raster and PSTH","title":"Raster and PSTH","text":"Stats.gaussian_kernel\nStats.get_histogram_center\nStats.histogram_fhist\nStats.histogram_gsl","category":"page"},{"location":"raster_psth/#SpikeTriggered.Stats.gaussian_kernel","page":"Raster and PSTH","title":"SpikeTriggered.Stats.gaussian_kernel","text":"gaussian_kernel(x::T; σ::T=0.005)\n\nInline Gaussian function.\n\ng(x) = fracexp(-fracx^22 σ^2)sqrt2pi σ\n\n\n\n\n\n","category":"function"},{"location":"raster_psth/#SpikeTriggered.Stats.get_histogram_center","page":"Raster and PSTH","title":"SpikeTriggered.Stats.get_histogram_center","text":"get_histogram_center(edges)\n\nget the center of edge vector. make sure edges are sorted.\n\n\n\n\n\n","category":"function"},{"location":"raster_psth/#SpikeTriggered.Stats.histogram_fhist","page":"Raster and PSTH","title":"SpikeTriggered.Stats.histogram_fhist","text":"histogram_fhist(u_arr, edges; kwargs...) -> Vector\n\nCount histogram using FHist.Hist1D, which has similar performance as GSL.\n\nkwargs will be relayed to FHist.Hist1D; for example, one could set element type of the histogram to Float32 by passing counttype=Float32.\n\n\n\n\n\n","category":"function"},{"location":"raster_psth/#SpikeTriggered.Stats.histogram_gsl","page":"Raster and PSTH","title":"SpikeTriggered.Stats.histogram_gsl","text":"histogram_gsl(u_arr, edges) where {T <: Real}\n\nCount histogram by providing the edges. If provides n+1 edges, it would return n length histogram. Edges would work as: left bound <= value < right bound.\n\nArguments\n\nu_arr: a vector of values\nedges: a vector of edges\n\nNote: StatsBase.Histogram is slower than GSL but with less memory footprint.\n\n\n\n\n\n","category":"function"},{"location":"reverse_correlation/#Reverse-Correlation","page":"Reverse Correlation","title":"Reverse Correlation","text":"","category":"section"},{"location":"reverse_correlation/","page":"Reverse Correlation","title":"Reverse Correlation","text":"Probabily the most important analysis, the foundation of estimating the spatiotemporal receptive fields, of the first-order component (Spike-Triggered Average) and higher-order component (Spike-Triggered Covariance)[schwartzSpiketriggeredNeuralCharacterization2006]. The basic idea is the features of the stimulus that drive the cellular responses (e.g., spikes) is the features of the receptive fields.","category":"page"},{"location":"reverse_correlation/","page":"Reverse Correlation","title":"Reverse Correlation","text":"Usually the features here are continous random vairables (e.g., noise stimuli), it can also be the movie stimulus itself. No matter what feature you choose, the stimulus matrix for this analysis should be organized as [nDimensions x nTimepoints]; and the reverse correlation would be [nDimensions x nFrames].","category":"page"},{"location":"reverse_correlation/#Spike-Triggered-Average","page":"Reverse Correlation","title":"Spike-Triggered Average","text":"","category":"section"},{"location":"reverse_correlation/","page":"Reverse Correlation","title":"Reverse Correlation","text":"The first order component, which is equivalent to the weighted average of the stimulus before spikes.","category":"page"},{"location":"reverse_correlation/","page":"Reverse Correlation","title":"Reverse Correlation","text":"operatornameSTA(n) = frac1N sum_i=1^N vecs(n t_i)","category":"page"},{"location":"reverse_correlation/","page":"Reverse Correlation","title":"Reverse Correlation","text":"where t_i is the spike time and vecs(n t_i) is the stimulus feature vector related to the spike.","category":"page"},{"location":"reverse_correlation/#bootstrapped-spike-tiriggered-average","page":"Reverse Correlation","title":"bootstrapped spike-tiriggered average","text":"","category":"section"},{"location":"reverse_correlation/","page":"Reverse Correlation","title":"Reverse Correlation","text":"TODO","category":"page"},{"location":"reverse_correlation/#Spike-Triggered-Covariance","page":"Reverse Correlation","title":"Spike-Triggered Covariance","text":"","category":"section"},{"location":"reverse_correlation/","page":"Reverse Correlation","title":"Reverse Correlation","text":"TODO","category":"page"},{"location":"reverse_correlation/#References","page":"Reverse Correlation","title":"References","text":"","category":"section"},{"location":"reverse_correlation/","page":"Reverse Correlation","title":"Reverse Correlation","text":"[schwartzSpiketriggeredNeuralCharacterization2006]: Schwartz, O., Pillow, J. W., Rust, N. C. & Simoncelli, E. P. Spike-triggered neural characterization. Journal of Vision 6, 484–507 (2006).","category":"page"},{"location":"reverse_correlation/#Functions","page":"Reverse Correlation","title":"Functions","text":"","category":"section"},{"location":"reverse_correlation/#exported-functions","page":"Reverse Correlation","title":"exported functions","text":"","category":"section"},{"location":"reverse_correlation/","page":"Reverse Correlation","title":"Reverse Correlation","text":"spike_triggered_average","category":"page"},{"location":"reverse_correlation/#SpikeTriggered.Stats.spike_triggered_average","page":"Reverse Correlation","title":"SpikeTriggered.Stats.spike_triggered_average","text":"spike_triggered_average(stimulus, psth; n=10)\nspike_triggered_average(stimulus, spike_train, marker; n=10)\nspike_triggered_average(stimulus, raster, marker; n=10)\n\nGet the STA, which can be reshaped into 2d/3d matrix with make_strf and hstack_strf.\n\nIf psth is 2d matrix (nTimepoints x nRepeats), the average of PSTH across trials will be used.\n\nA = frac1N sum_n=1^Nvecs(t_n)\n\n\n\n\n\n","category":"function"},{"location":"#SpikeTriggered.jl-Documentation","page":"Home","title":"SpikeTriggered.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"warning: Warning\nThis documentation is still work in progress.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The SpikeTriggered package provides a collection of functions for analysis related to spike trains. Including:","category":"page"},{"location":"","page":"Home","title":"Home","text":"converting spike trains into rasters.\ngetting PSTH from spike trains, by using histogram or (Gaussian) filter.\nestimating RFs using forward correlation and reserve correlation (e.g., spike-triggered averaging).\nthresholding waveforms to extract spike events (for simple online estimation).\netc.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To keep things simple, PSTH and spike trains are represented as AbstractVector{T}, rasters are AbstractVector{<:AbstractVector{T}}, and other statistics are using Julia's built-in types whenever possible.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Functions for spike train statistics are in the Stats submodule and functions for waveform processing are in the Waveforms submodule. Functions in the Stimulus submodule are only for internal uses in HirschLab.","category":"page"},{"location":"","page":"Home","title":"Home","text":"PSTHs and rasters are usually the foundation of all the analysis; so please double check your marker times are correct (e.g., there might be some jitters during stimulus generation, or there might be an offset between the marker and spike times between the stimulus generator and data collection).","category":"page"},{"location":"","page":"Home","title":"Home","text":"For visualization, checkout the NeuroMakie.jl package.","category":"page"},{"location":"strf/#Spatiotemporal-Receptive-Field","page":"Spatiotemporal Receptive Field","title":"Spatiotemporal Receptive Field","text":"","category":"section"},{"location":"strf/#Footprint-Analysis","page":"Spatiotemporal Receptive Field","title":"Footprint Analysis","text":"","category":"section"},{"location":"strf/","page":"Spatiotemporal Receptive Field","title":"Spatiotemporal Receptive Field","text":"Using Benjamini-Hochberg procedure to adaptively thresholding the zscore STA from the bootstrapped spike-tiriggered average. The footprint is the spatial component of the entire strf.","category":"page"},{"location":"spike_stats/#Spike-Statistics","page":"Spike Statistics","title":"Spike Statistics","text":"","category":"section"},{"location":"spike_stats/#Burst-detection-and-features","page":"Spike Statistics","title":"Burst detection and features","text":"","category":"section"},{"location":"spike_stats/#Functions","page":"Spike Statistics","title":"Functions","text":"","category":"section"},{"location":"spike_stats/","page":"Spike Statistics","title":"Spike Statistics","text":"Stats.burst_detect","category":"page"},{"location":"spike_stats/#SpikeTriggered.Stats.burst_detect","page":"Spike Statistics","title":"SpikeTriggered.Stats.burst_detect","text":"burst_detect(spk::Vector; t_silence=0.07, t_isi=0.03, nofs=nothing, keep_index=false) -> Vector{Vector{T}}\n\nBurst firing identification based on the rules:\n\na burst would followed/preceded by a silence t_silence time;\n\nif t_silence is a 2 element tuple, the t_silence[1] will set the preceded time and t_silence[2] will be the followed time.\n\neach spike spaced at most t_isi time, otherwise terminated\n(optional) at least nofs[1] spikes within the first nofs[2] time\n\nIf keep_index is true, will return indices of spikes within the input; otherwise, the spike times will be returned.\n\nReferences:\n\nVaingankar et al 2012\n\n\n\n\n\n","category":"function"}]
}
