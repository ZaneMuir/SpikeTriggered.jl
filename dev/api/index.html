<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>APIs · SpikeTriggered.jl</title><meta name="title" content="APIs · SpikeTriggered.jl"/><meta property="og:title" content="APIs · SpikeTriggered.jl"/><meta property="twitter:title" content="APIs · SpikeTriggered.jl"/><meta name="description" content="Documentation for SpikeTriggered.jl."/><meta property="og:description" content="Documentation for SpikeTriggered.jl."/><meta property="twitter:description" content="Documentation for SpikeTriggered.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SpikeTriggered.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../spike_stats/">Spike Statistics</a></li><li><a class="tocitem" href="../raster_psth/">Raster and PSTH</a></li><li><a class="tocitem" href="../reverse_correlation/">Reverse Correlation</a></li><li><a class="tocitem" href="../strf/">Spatiotemporal Receptive Field</a></li><li class="is-active"><a class="tocitem" href>APIs</a><ul class="internal"><li><a class="tocitem" href="#Stats"><span>Stats</span></a></li><li><a class="tocitem" href="#Waveforms"><span>Waveforms</span></a></li><li><a class="tocitem" href="#Stimulus"><span>Stimulus</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>APIs</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>APIs</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="APIs"><a class="docs-heading-anchor" href="#APIs">APIs</a><a id="APIs-1"></a><a class="docs-heading-anchor-permalink" href="#APIs" title="Permalink"></a></h1><h2 id="Stats"><a class="docs-heading-anchor" href="#Stats">Stats</a><a id="Stats-1"></a><a class="docs-heading-anchor-permalink" href="#Stats" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpikeTriggered.Stats.benjamini_hochberg_qvalue-Tuple{AbstractArray}" href="#SpikeTriggered.Stats.benjamini_hochberg_qvalue-Tuple{AbstractArray}"><code>SpikeTriggered.Stats.benjamini_hochberg_qvalue</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">benjamini_hochberg_qvalue(pvalue; C=1) -&gt; (q::Array, k::Array)</code></pre><p>False discovery rate test for any list of pvalues. This function will return the <code>q</code> value and the corresponding <code>k</code> index.</p><p class="math-container">\[P_k \leq \frac{k}{N} \alpha\]</p><p class="math-container">\[q_k = \frac{N}{k} P_k \leq \alpha\]</p><p><code>k</code> is generated from <code>invperm(sortperm(...))</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpikeTriggered.Stats.burst_detect-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:Real" href="#SpikeTriggered.Stats.burst_detect-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:Real"><code>SpikeTriggered.Stats.burst_detect</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">burst_detect(spk::Vector; t_silence=0.07, t_isi=0.03, nofs=nothing, keep_index=false) -&gt; Vector{Vector{T}}</code></pre><p>Burst firing identification based on the rules:</p><ul><li>a burst would followed/preceded by a silence <code>t_silence</code> time;</li></ul><p>if <code>t_silence</code> is a 2 element tuple, the <code>t_silence[1]</code> will set the preceded time and <code>t_silence[2]</code> will be the followed time.</p><ul><li>each spike spaced at most <code>t_isi</code> time, otherwise terminated</li><li>(optional) at least <code>nofs[1]</code> spikes within the first <code>nofs[2]</code> time</li></ul><p>If <code>keep_index</code> is <code>true</code>, will return indices of spikes within the input; otherwise, the spike times will be returned.</p><p>References:</p><ul><li><a href="https://doi.org/10.3389/fnint.2012.00118">Vaingankar et al 2012</a></li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpikeTriggered.Stats.burst_detect_lgn-Tuple{Any}" href="#SpikeTriggered.Stats.burst_detect_lgn-Tuple{Any}"><code>SpikeTriggered.Stats.burst_detect_lgn</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">detect_burst_lgn(spk; kwargs...)</code></pre><p>Bursts were defined as two or more spikes, each spaced ≤4 ms apart following ≥100 ms of silence, bursts rarely lasted more than 10 ms for LGN.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpikeTriggered.Stats.burst_detect_trn-Tuple{Any}" href="#SpikeTriggered.Stats.burst_detect_trn-Tuple{Any}"><code>SpikeTriggered.Stats.burst_detect_trn</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">detect_burst_trn(spk; kwargs...)</code></pre><p>≥5 spikes within 70 ms, spaced ≤30 ms apart following ≥70 ms of silence; bursts were terminated when the interspike interval exceeded 30 ms, Figure 1B. Thus defined, typical bursts had 5–17 spikes. Typical bursts lasted between 70 and 100 ms.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpikeTriggered.Stats.burst_interpolate-Tuple{AbstractVector}" href="#SpikeTriggered.Stats.burst_interpolate-Tuple{AbstractVector}"><code>SpikeTriggered.Stats.burst_interpolate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">interp_burst(burst_iti::AbstractVector; n=13, interp_t=:steffen) -&gt; Vector{Float64}
interp_burst(bursts::Vector{Vector{Real}}; n=13, interp_t=:steffen) -&gt; Matrix{Float64} [n x nBursts]</code></pre><p>Make interpolation of burst inter-spike-interval to generate burst patterns.</p><p><code>n</code> set the interpolation bin length. <code>interp_t</code> set the type of interpolation, currently only supports [<code>:linear</code>, <code>:polynomial</code>, <code>:cspline</code>, <code>:steffen</code>]. The results will always be in <code>Cdouble</code> precision.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpikeTriggered.Stats.covariogram-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}}} where T&lt;:Real" href="#SpikeTriggered.Stats.covariogram-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}}} where T&lt;:Real"><code>SpikeTriggered.Stats.covariogram</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>The covariogram is defined as:</p><p class="math-container">\[V \equiv \langle (S_1^{r} - P_1) \odot (S_2^{r} - P_2) \rangle = \langle S_1^{r} \odot S_2^{r} \rangle - P_1 \odot P_2\]</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpikeTriggered.Stats.dispersion_index-Tuple{Any}" href="#SpikeTriggered.Stats.dispersion_index-Tuple{Any}"><code>SpikeTriggered.Stats.dispersion_index</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dispersion_index(psth; corrected=true, kwargs...) -&gt; Real</code></pre><p>Also known as the <code>Fano factor</code>.</p><p class="math-container">\[D = \frac{\sigma^2}{\mu}\]</p><p><strong>optional arguments:</strong></p><ul><li><code>dims</code>: calculate the index over dimension <code>dims</code>.</li></ul><p>Check out more on <a href="https://en.wikipedia.org/wiki/Index_of_dispersion">wikipedia</a>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpikeTriggered.Stats.gaussian_kernel-Tuple{T} where T&lt;:AbstractFloat" href="#SpikeTriggered.Stats.gaussian_kernel-Tuple{T} where T&lt;:AbstractFloat"><code>SpikeTriggered.Stats.gaussian_kernel</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gaussian_kernel(x::T; σ::T=0.005)</code></pre><p>Inline <a href="https://en.wikipedia.org/wiki/Gaussian_filter">Gaussian function</a>.</p><p class="math-container">\[g(x) = \frac{\exp(-\frac{x^2}{2 σ^2})}{\sqrt{2\pi} σ}\]</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpikeTriggered.Stats.get_footprint_map-Tuple{Function, AbstractArray}" href="#SpikeTriggered.Stats.get_footprint_map-Tuple{Function, AbstractArray}"><code>SpikeTriggered.Stats.get_footprint_map</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_footprint_map([func_pval,] raw::AbstractArray; alpha=0.01, fdr_c=1, collapse=false, gridsize=nothing)</code></pre><p>Create a footprint map based on the q-values from <code>func_pval(raw)</code> using Benjamini–Hochberg procedure; <code>alpha</code> as the threshold, fdr_c as the constant.</p><p class="math-container">\[P_k \leq \frac{k}{N \cdot C} \alpha\]</p><p>For arbiturary join distribution of p-values, one could set <code>fdr_c</code> as <code>ln(N)+1/N+γ (Euler constant)</code>. (using <code>benjamini_hochberg_constant(N)</code>)</p><p>If <code>collapse</code> is <code>true</code> and <code>gridsize</code> is specified, a 2d time-collapsed footprint map will be returned.</p><p>color codes as:</p><ul><li><code>1</code>: ON response</li><li><code>0</code>: NO response</li><li><code>-1</code>: OFF response</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpikeTriggered.Stats.get_footprint_mask-Tuple{Function, AbstractArray}" href="#SpikeTriggered.Stats.get_footprint_mask-Tuple{Function, AbstractArray}"><code>SpikeTriggered.Stats.get_footprint_mask</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_footprint_mask([func_pval::Function,] raw::AbstractArray; alpha=0.01, fdr_c=1)</code></pre><p>Create a binary footprint mask based with Benjamini–Hochberg procedure using arbiturary q-values converted from <code>raw</code> statistic values by <code>func_pval</code>.</p><p>In most cases, one should use <code>get_footprint_map</code> which can also generate 3d mask with addtional polarity information.</p><p>If <code>func_pval</code> is not set, <code>zscore_pvalue</code> will be used, which assumes inputs are zscore from standard normal distribution.</p><p><code>alpha</code> if the threshold for false discovery rate, default as <code>0.01</code>.</p><p><code>fdr_c</code> is the constant value for correcting Benjamini–Hochberg procedure with joint distributions among pvalues.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpikeTriggered.Stats.get_footprint_mask_from_qvalue-Tuple{Any, Any}" href="#SpikeTriggered.Stats.get_footprint_mask_from_qvalue-Tuple{Any, Any}"><code>SpikeTriggered.Stats.get_footprint_mask_from_qvalue</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_footprint_mask_from_qvalue(qval, k; alpha=0.01)</code></pre><p>create a binary footprint mask based on the q-values and the corresponding permutation vector. Using Benjamini–Hochberg procedure.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpikeTriggered.Stats.get_histogram_center-Tuple{AbstractVector}" href="#SpikeTriggered.Stats.get_histogram_center-Tuple{AbstractVector}"><code>SpikeTriggered.Stats.get_histogram_center</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_histogram_center(edges)</code></pre><p>get the center of edge vector. make sure edges are sorted.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpikeTriggered.Stats.histogram_fhist-Tuple{AbstractVector, Any}" href="#SpikeTriggered.Stats.histogram_fhist-Tuple{AbstractVector, Any}"><code>SpikeTriggered.Stats.histogram_fhist</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">histogram_fhist(u_arr, edges; kwargs...) -&gt; Vector</code></pre><p>Count histogram using <code>FHist.Hist1D</code>, which has similar performance as <code>GSL</code>.</p><p><code>kwargs</code> will be relayed to <code>FHist.Hist1D</code>; for example, one could set element type of the histogram to <code>Float32</code> by passing <code>counttype=Float32</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpikeTriggered.Stats.histogram_gsl-Union{Tuple{T}, Tuple{AbstractVector{T}, Any}} where T&lt;:Real" href="#SpikeTriggered.Stats.histogram_gsl-Union{Tuple{T}, Tuple{AbstractVector{T}, Any}} where T&lt;:Real"><code>SpikeTriggered.Stats.histogram_gsl</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">histogram_gsl(u_arr, edges) where {T &lt;: Real}</code></pre><p>Count histogram by providing the edges. If provides <code>n+1</code> edges, it would return <code>n</code> length histogram. Edges would work as: left bound &lt;= value &lt; right bound.</p><p><strong>Arguments</strong></p><ul><li><code>u_arr</code>: a vector of values</li><li><code>edges</code>: a vector of edges</li></ul><p>Note: StatsBase.Histogram is slower than GSL but with less memory footprint.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpikeTriggered.Stats.hstack_strf-Tuple{AbstractArray}" href="#SpikeTriggered.Stats.hstack_strf-Tuple{AbstractArray}"><code>SpikeTriggered.Stats.hstack_strf</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hstack_strf(val; gridsize) -&gt; Array{T, 2} Sx(SxT)</code></pre><p>convert strf 3d matrix into horizontal matrix.</p><p>When plotting with heatmap, REMEMBER to use the transversed matrix and reversed y axis.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpikeTriggered.Stats.image2dataset-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T" href="#SpikeTriggered.Stats.image2dataset-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T"><code>SpikeTriggered.Stats.image2dataset</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">image2dataset(image::AbstractMatrix) -&gt; ([X Y], [Z])</code></pre><p>convert 2d image into <code>(x, y)</code> coordinates and vector of elements (<code>z</code>). Primarilly used for 2d gaussian fit.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpikeTriggered.Stats.make_strf-Tuple{AbstractArray}" href="#SpikeTriggered.Stats.make_strf-Tuple{AbstractArray}"><code>SpikeTriggered.Stats.make_strf</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">make_strf(val; gridsize) -&gt; Array{T, 3} SxSxT</code></pre><p>convert strf vector into 3d spatiotemporal matrix.</p><p>When plotting with heatmap, REMEMBER to use the transversed matrix and reversed y axis.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpikeTriggered.Stats.schreiber_score_matrix-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:Real" href="#SpikeTriggered.Stats.schreiber_score_matrix-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:Real"><code>SpikeTriggered.Stats.schreiber_score_matrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Schreiber reliability score:</p><p class="math-container">\[R_{\text{corr}} = \frac{2}{N(N-1)} \sum_{i = 1}^N \sum_{j = i+1} ^N \frac{\vec{s}_i \cdot \vec{s}_j}{|\vec{s}_i| |\vec{s}_j|}\]</p><p>Input in shape of <code>[nPSTH x nTrial]</code></p><p>reference: dx.doi.org/10.1016/S0925-2312(02)00838-X</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpikeTriggered.Stats.spike_histogram-Tuple{AbstractVector, AbstractMatrix}" href="#SpikeTriggered.Stats.spike_histogram-Tuple{AbstractVector, AbstractMatrix}"><code>SpikeTriggered.Stats.spike_histogram</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">spike_histogram(spike_train, edges::AbstractMatrix; kwargs...) -&gt; Matrix{T}</code></pre><p>Peri-stimulus time histogram with multiple trials. <code>edges</code> should be shape of [<code>n+1</code> x nRepeats] to create a histogram of shape [<code>n</code> x nRepeats].</p><p>If <code>dims</code> is specified, trial dimension will be overwrite.</p><p>Additional <code>kwargs</code> will be passed to <code>spike_histogram</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpikeTriggered.Stats.spike_histogram-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector}} where T&lt;:Real" href="#SpikeTriggered.Stats.spike_histogram-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector}} where T&lt;:Real"><code>SpikeTriggered.Stats.spike_histogram</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">spike_histogram(spike_train::AbstractVector{T}, edges::AbstractVector; dtype::Type, kwargs...) -&gt; Vector{T}</code></pre><p>Peri-stimulus time histogram. <code>edges</code> should be length of <code>n+1</code> to create a histogram of length <code>n</code>.</p><p>If <code>spike_train</code> is empty, it will return <code>zeros(T, n)</code></p><p>If <code>counttype</code> is not specified, the returned vector will have same type <code>T</code></p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpikeTriggered.Stats.spike_histogram-Union{Tuple{T}, Tuple{Array{Vector{T}, 1}, Vararg{Any}}} where T&lt;:Real" href="#SpikeTriggered.Stats.spike_histogram-Union{Tuple{T}, Tuple{Array{Vector{T}, 1}, Vararg{Any}}} where T&lt;:Real"><code>SpikeTriggered.Stats.spike_histogram</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">spike_histogram(raster::SpikeRaster{T}, args...; norm=true, kwargs...) -&gt; VecOrMat{T}</code></pre><p>PSTH from averaging rasters.</p><p>If <code>norm</code> is <code>true</code>, PSTH will be normalized by the length of trials.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpikeTriggered.Stats.spike_histogram_smoothed-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractArray}, Tuple{AbstractVector{T}, AbstractArray, Function}} where T&lt;:Real" href="#SpikeTriggered.Stats.spike_histogram_smoothed-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractArray}, Tuple{AbstractVector{T}, AbstractArray, Function}} where T&lt;:Real"><code>SpikeTriggered.Stats.spike_histogram_smoothed</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">spike_histogram_smoothed(spike_train::SpikeTrain{T}, projection::AbstractArray, kernel::Function=gaussian_kernel; norm=true, kwargs...) -&gt; Vector{T}</code></pre><p>Generating smoothed curve from spike trains. Equivalent to convolution.</p><p class="math-container">\[\text{PSTH}(t) = (h * s)(t) = \sum_i \delta(t - t&#39;_i) h (t - t&#39;_i),\; t \in \text{proj}\]</p><p>If <code>norm</code> is <code>true</code>, the results will be normalized by the maximum value.</p><p>All <code>kwargs</code> will be passed to <code>kernel</code> function.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpikeTriggered.Stats.spike_histogram_smoothed-Union{Tuple{T}, Tuple{Array{Vector{T}, 1}, Vararg{Any}}} where T&lt;:Real" href="#SpikeTriggered.Stats.spike_histogram_smoothed-Union{Tuple{T}, Tuple{Array{Vector{T}, 1}, Vararg{Any}}} where T&lt;:Real"><code>SpikeTriggered.Stats.spike_histogram_smoothed</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">spike_histogram_smoothed(raster, args...; kwargs...) where {T &lt;: Real} -&gt; Vector{T}</code></pre><p>Generating smoothed PSTH from rasters.</p><p>If <code>norm</code> is <code>true</code>, PSTH will be normalized to the maximum number; otherwise, it will be divided by the number of trials in the raster.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpikeTriggered.Stats.spike_raster-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector}} where T&lt;:Real" href="#SpikeTriggered.Stats.spike_raster-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector}} where T&lt;:Real"><code>SpikeTriggered.Stats.spike_raster</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">spike_raster(spike_train::AbstractVector{T}, markers::AbstractVector; head=0.5, duration=1.0, tail=0.5, offset=true) -&gt; Vector{Vector{T}}</code></pre><p>Create rasters from <code>spike_train</code> and onset times of stimulus (<code>markers</code>), with interval of <code>(marker-head, marker+duration+tail]</code>.</p><p>If <code>offset</code> is <code>true</code>, spike times of each trial be relative to the onset time.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpikeTriggered.Stats.spike_train_spectrum_power-Union{Tuple{T}, Tuple{AbstractVector{T}, Any}} where T&lt;:AbstractFloat" href="#SpikeTriggered.Stats.spike_train_spectrum_power-Union{Tuple{T}, Tuple{AbstractVector{T}, Any}} where T&lt;:AbstractFloat"><code>SpikeTriggered.Stats.spike_train_spectrum_power</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">spike_train_spectrum_power(spks::AbstractSpikeTrain{T}, freq; t_len=1) where {T &lt;: AbstractFloat}</code></pre><p>The spike-train power spectrum is computed from the Fourier transform of the spike train, as in (Dummer, et al., 2014).</p><p class="math-container">\[S(f) = \frac{\langle \tilde{x} \tilde{x}^\ast \rangle}{T}\]</p><p>The neural spike train is represented by a sum of delta functions at the spike times:</p><p class="math-container">\[x(t) = \sum_i \delta(t - t_i)\]</p><p>The Fourier transform for the time window is defined by</p><p class="math-container">\[\tilde{x}(f) = \int_0^{T} e^{- 2 \pi j f t} x(t)\; dt\]</p><p><strong>Reference:</strong></p><ul><li>Dummer, B., Wieland, S. &amp; Lindner, B. Self-consistent determination of the spike-train power spectrum in a neural network with sparse connectivity. Front. Comput. Neurosci. 8, (2014). DOI: 10.3389/fncom.2014.00104</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpikeTriggered.Stats.spike_triggered_average-Tuple{AbstractMatrix, AbstractVector}" href="#SpikeTriggered.Stats.spike_triggered_average-Tuple{AbstractMatrix, AbstractVector}"><code>SpikeTriggered.Stats.spike_triggered_average</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">spike_triggered_average(stimulus, psth; n=10)
spike_triggered_average(stimulus, spike_train, marker; n=10)
spike_triggered_average(stimulus, raster, marker; n=10)</code></pre><p>Get the STA, which can be reshaped into 2d/3d matrix with <code>make_strf</code> and <code>hstack_strf</code>.</p><p>If <code>psth</code> is 2d matrix (nTimepoints x nRepeats), the average of PSTH across trials will be used.</p><p class="math-container">\[A = \frac{1}{N} \sum_{n=1}^{N}\vec{s}(t_n)\]</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpikeTriggered.Stats.spike_triggered_average_suite-Tuple{Any, Vararg{Any}}" href="#SpikeTriggered.Stats.spike_triggered_average_suite-Tuple{Any, Vararg{Any}}"><code>SpikeTriggered.Stats.spike_triggered_average_suite</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">spike_triggered_average_suite(args...; kwargs...) -&gt; (; diff, on, off)</code></pre><p>Create STAs of difference map, on map and off map; returns a named tuple.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpikeTriggered.Stats.spike_triggered_average_zscore-Tuple" href="#SpikeTriggered.Stats.spike_triggered_average_zscore-Tuple"><code>SpikeTriggered.Stats.spike_triggered_average_zscore</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">spike_triggered_average_zscore(args...; kwargs...)</code></pre><p>Estimate z-scores of STA.</p><p>Same <code>args...</code> as <code>spike_triggered_average</code>.</p><p>If <code>n</code> is specified, only <code>n</code> frames are included for zscore (same as sta, default as <code>10</code>`).</p><p><code>bootstrap</code> set the bootstrapping iterations, default as <code>1000</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpikeTriggered.Stats.spike_triggered_covariance-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractArray{T}}} where T" href="#SpikeTriggered.Stats.spike_triggered_covariance-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractArray{T}}} where T"><code>SpikeTriggered.Stats.spike_triggered_covariance</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">spike_triggered_covariance(X::AbstractMatrix{T}, y::AbstractArray{T}; n::Integer=10, verbose=true) where {T, U} -&gt; Matrix{T}</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpikeTriggered.Stats.spike_xcorr-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector}} where T&lt;:Real" href="#SpikeTriggered.Stats.spike_xcorr-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector}} where T&lt;:Real"><code>SpikeTriggered.Stats.spike_xcorr</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">spike_xcorr(target, reference, roi) where {T &lt;: Real}</code></pre><p>The crosscorrelogram shows a count of the spikes of the target cell at specific time delays with respect the spikes of the reference cell.</p><p>If there are multiple trials, use the <code>spike_xcorr_shifted</code> to correct any bias with a shift predictor.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpikeTriggered.Stats.spike_xcorr_shifted-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector}} where T&lt;:Real" href="#SpikeTriggered.Stats.spike_xcorr_shifted-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector}} where T&lt;:Real"><code>SpikeTriggered.Stats.spike_xcorr_shifted</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">spike_xcorr_shifted(target, reference, roi; shift_t, shift_t_end) where {T &lt;: Real}</code></pre><p>The crosscorrelogram shows a count of the spikes of the target cell at specific time delays with respect the spikes of the reference cell. Corrected with a shift predictor.</p><p><strong>Keyword Arguments:</strong></p><ul><li>shift_t: Δt of each shift, usually shift the spike by trials</li><li>shift<em>t</em>end: the end limit of spike_time, usually the end time of the last trial. [default: maximum(reference)]</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpikeTriggered.Stats.split_tonic_burst-Tuple{Any}" href="#SpikeTriggered.Stats.split_tonic_burst-Tuple{Any}"><code>SpikeTriggered.Stats.split_tonic_burst</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">split_tonic_burst(spk; detector, kwargs...) -&gt; (; burst::Vector{Vector}, tonic::Vector)</code></pre><p>Split spike train into burst and tonic groups using <code>detector</code> function.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpikeTriggered.Stats.split_tonic_cardinal-Tuple{Any}" href="#SpikeTriggered.Stats.split_tonic_cardinal-Tuple{Any}"><code>SpikeTriggered.Stats.split_tonic_cardinal</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">split_tonic_cardinal(spk; detector, kwargs...) -&gt; (; burst::Vector, tonic::Vector)</code></pre><p>Split spike train into burst and tonic groups using <code>detector</code> function. But only the cardinal spike of burst is returned.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpikeTriggered.Stats.zscore_pvalue-Tuple{AbstractArray}" href="#SpikeTriggered.Stats.zscore_pvalue-Tuple{AbstractArray}"><code>SpikeTriggered.Stats.zscore_pvalue</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">zscore_pvalue(zscore::AbstractArray; two_tailed=true)</code></pre><p>get pvalue from standard normal distribution</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpikeTriggered.Stats.SpatialRF.schiller_overlap_index-Tuple{SpikeTriggered.Stats.SpatialRF.GaussianEllipse, SpikeTriggered.Stats.SpatialRF.GaussianEllipse}" href="#SpikeTriggered.Stats.SpatialRF.schiller_overlap_index-Tuple{SpikeTriggered.Stats.SpatialRF.GaussianEllipse, SpikeTriggered.Stats.SpatialRF.GaussianEllipse}"><code>SpikeTriggered.Stats.SpatialRF.schiller_overlap_index</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">schiller_overlap_index(e1::GaussianEllipse, e2::GaussianEllipse)</code></pre><p>overlap of two spatial receptive fields based on Schiller&#39;s overlap index.</p><p>For two receptive fields with the Gaussian parameters (<span>$\alpha$</span>, <span>$\sigma_a$</span>, <span>$\sigma_b$</span>, <span>$\theta$</span>, <span>$x_0$</span>, <span>$y_0$</span>), the 2D overlap index is defined as:</p><p class="math-container">\[\Omega = \frac{\sigma_{12} + \sigma_{21} - d}{\sigma_{12} + \sigma_{21} + d}\]</p><p>Where <span>$d$</span> is the Euclidian distance between the centers, and:</p><p class="math-container">\[\sigma_{ij} = \frac{\sigma_{ai}\sigma_{bi}}{\sqrt{
\sigma_{ai}^2 \sin^2(\theta_i - \phi_{ij}) +
\sigma_{bi}^2 \cos^2(\theta_i - \phi_{ij})
}}\]</p><p class="math-container">\[\phi_{ij} = \arctan\left(\frac{y_{0j} - y_{0i}}{x_{0j} - x_{0i}}\right)\]</p><p><strong>References</strong></p><ul><li>Schiller et al., 1979</li><li>Wang et al., 2007</li></ul></div></section></article><h2 id="Waveforms"><a class="docs-heading-anchor" href="#Waveforms">Waveforms</a><a id="Waveforms-1"></a><a class="docs-heading-anchor-permalink" href="#Waveforms" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpikeTriggered.Waveforms.detect_cross_pnt-Union{Tuple{Vector{T}}, Tuple{T}} where T" href="#SpikeTriggered.Waveforms.detect_cross_pnt-Union{Tuple{Vector{T}}, Tuple{T}} where T"><code>SpikeTriggered.Waveforms.detect_cross_pnt</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">detect_cross_pnt(arr; thresh, gap=1, dir=:up, ref=nothing)</code></pre><p>detect data rise or data down points.</p><p><strong>Arguments</strong></p><ul><li><code>arr</code>: a vector of traces.</li><li><code>thresh</code>: threshold</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpikeTriggered.Waveforms.gaussian_filter_gsl-Tuple{Vector{Float64}}" href="#SpikeTriggered.Waveforms.gaussian_filter_gsl-Tuple{Vector{Float64}}"><code>SpikeTriggered.Waveforms.gaussian_filter_gsl</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gaussian_filter_gsl(arr::Vector{Float64}; K::Integer, α::Real=1)</code></pre><p>The GSL gaussian kernel is defined by:</p><p class="math-container">\[G(k) = \exp\left(- \frac{k^2}{2 \sigma^2}\right)\]</p><p>for <span>$-(K-1)/2 \leq k \leq (K-1)/2$</span>, and <span>$K$</span> is the size of the kernel. The parameter <span>$\alpha$</span> specifies the number of standard deviations <span>$\sigma$</span> desired in the kernel.</p><p class="math-container">\[\sigma = \frac{K-1}{2 \alpha}\]</p></div></section></article><h2 id="Stimulus"><a class="docs-heading-anchor" href="#Stimulus">Stimulus</a><a id="Stimulus-1"></a><a class="docs-heading-anchor-permalink" href="#Stimulus" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpikeTriggered.Stimulus.apply_video_nonlinearity" href="#SpikeTriggered.Stimulus.apply_video_nonlinearity"><code>SpikeTriggered.Stimulus.apply_video_nonlinearity</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">apply_video_nonlinearity(video, bias=0) -&gt; video</code></pre><p>For sparse noise stimuli, to retrieve nonlinear map (ON map and OFF map) by ignore bright/dark spots.</p><p><strong>Arguments</strong></p><ul><li>video: the original video matrix</li><li>bias: could be either values or symbols<ul><li>ON: <code>:on</code> or <code>-1</code></li><li>OFF: <code>:off</code> or <code>1</code></li><li>DIFF: <code>:diff</code> or <code>0</code></li></ul></li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpikeTriggered.Stimulus.load_snra-Tuple{String}" href="#SpikeTriggered.Stimulus.load_snra-Tuple{String}"><code>SpikeTriggered.Stimulus.load_snra</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">load_snra(snf_path::String) -&gt; Vector{Int16}</code></pre><p>read <code>snf</code> sparse noise pseudorandom files</p><p><strong>Synopsis</strong></p><pre><code class="language-c hljs">struct SNF {
    int16_t n_order;
    int32_t base_poly; // not sure what it represents
    int16_t* snra; // the length would be 2^n_order
};</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpikeTriggered.Stimulus.parse_snra-Union{Tuple{T}, Tuple{Array{T}, Integer}} where T&lt;:Integer" href="#SpikeTriggered.Stimulus.parse_snra-Union{Tuple{T}, Tuple{Array{T}, Integer}} where T&lt;:Integer"><code>SpikeTriggered.Stimulus.parse_snra</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">parse_snra(snra::Array{T}, grid_size::Integer) -&gt; NamedTuple(:ids, :row, :col, :sign)</code></pre><p>parse the snra array to sparse noise image info.</p></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../strf/">« Spatiotemporal Receptive Field</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.6.0 on <span class="colophon-date" title="Friday 23 August 2024 19:59">Friday 23 August 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
